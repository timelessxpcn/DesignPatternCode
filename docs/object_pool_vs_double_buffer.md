# 对象池 vs 双缓冲 在嵌入式中的差异

| 维度 | 对象池 (Object Pool) | 双缓冲 (Double Buffer) |
|------|----------------------|------------------------|
| 核心目标 | 复用小对象，避免频繁分配释放 | 生产与消费数据批解耦，避免读写冲突 |
| 粒度 | 单个对象 | 整个缓冲块 |
| 数据结构 | 预分配数组 + 空闲链/位图 | 两个等长数组/缓冲 |
| 生命周期管理 | acquire/release | commit / swap |
| 内存占用 | N * sizeof(T) + 元数据 | 2 * BufferSize |
| 耗尽处理 | 需策略（丢弃/等待/覆盖） | 少见（固定 2 缓冲），可能出现生产过快（覆盖风险） |
| 典型场景 | 事件、命令、消息节点 | 传感器采样批处理、DMA ping-pong |
| 实时性 | O(1) 分配；耗尽时不可预测 | O(1) swap，确定性高 |
| 并发/ISR | ISR 可 acquire（无锁单生产） | ISR 写入写缓冲 + 条件 swap |
| 风险 | 重复释放 / 悬垂指针 | 忘记 swap 导致读取旧数据 |

选择指引：
- 若你需要频繁创建/销毁大量“小实体” → 对象池。
- 若你需要稳定批次数据交替消费（采集+处理） → 双缓冲。
- 二者可组合：双缓冲中存放指向对象池对象的指针集合。

实验建议：
1. 测量 acquire/release vs new/delete 周期。
2. 测量双缓冲 swap vs memcopy 两个缓冲再处理的时间差异。
