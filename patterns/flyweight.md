# 享元模式 (Flyweight Pattern)

## 1. 意图
通过共享大量细粒度对象的内在状态，减少内存占用；将可变/外部状态在使用时外部传入，避免重复存储。

## 2. 问题背景 / 动机
嵌入式内存紧张：例如 UI 字符渲染、协议常量表、滤波器系数集中，每个对象复制一份浪费 RAM/Flash。Flyweight 将不可变部分集中共享，只传递少量“外部上下文”进行操作。

## 3. 适用场景
- 字符/字形/图标渲染共享位图数据
- 协议命令描述（opcode -> 属性）
- 多个传感器实例共享校准常数集合
- 大量小对象的只读配置

## 4. 结构概述
FlyweightFactory 管理共享对象（内在状态）；客户端获取享元并在操作时提供外部状态（位置、当前读数等）。在嵌入式中可用：
- `constexpr` 静态表 + 获取指针
- 压缩表示（位打包）
- 避免运行期插入删除（多为静态集合）

## 5. 基础实现（静态表）
```cpp
struct CommandMeta {
    uint8_t opcode;
    uint8_t attr;
    const char* name;
};
constexpr CommandMeta gCommands[] = {
    {0x01, 0x02, "SET"},
    {0x02, 0x01, "GET"},
    {0x03, 0x04, "RESET"}
};
const CommandMeta* findCommand(uint8_t op){
    for(auto& c: gCommands) if(c.opcode == op) return &c;
    return nullptr;
}
```
共享元数据；外部状态是当前报文的 payload 等。

## 6. 嵌入式适配要点
- 优先放 Flash (constexpr) 节省 RAM。
- 索引查找可用二分/散列表（若规模大）。
- 避免运行期频繁变动：集合静态或启动构建一次。
- 压缩结构体：位域或字段合并。

## 7. 进阶实现
### 7.1 索引编码
使用 `uint8_t` 索引代替指针传递（更小 & 可序列化）。
### 7.2 共享不可变 + 可变分离
与 Prototype/Flyweight 组合：共享滤波系数数组；实例仅存 state。
### 7.3 稀疏池压缩
为大量低频对象，用稀疏映射 + 压缩数组 (对齐优化)。

## 8. 资源与实时性评估
- 查找 O(n)/O(logn)，可用完美哈希生成器。
- Flash 占用集中、RAM 减少。
- 访问间接增加一次指针/索引解析。

## 9. 替代比较
- 普通复制：简单但浪费内存。
- Prototype：复制一个基对象（更偏构建过程）。
- 对象池：管理生命周期，不共享内部常量。

## 10. 可测试性与可维护性
- 测试索引合法性：越界检查。
- 验证共享数据不被写入（const 防护）。
- 构建脚本自动生成表（减少手写错误）。

## 11. 适用性检查清单
Use：
- 大量重复不可变数据
- 内存/Flash 需要优化
Avoid：
- 对象数量少或无需共享
- 不可变/可变界限不清晰（易出错）

## 12. 常见误用 & 修正
误用：将可变状态也放入共享结构导致数据串扰。  
修正：严格区分内在/外在状态。

误用：过度碎片化为极小享元导致查找成本增大。  
修正：聚合小常量。

## 13. 与其它模式组合
- Prototype：享元提供基础不可变部分 -> 克隆添加可变部分。
- 对象池：池管理外在状态对象，内部引用共享享元。
- Builder：结合享元填充模板参数。

## 14. 案例
多种协议帧描述共享一个常量表，用于解码时查属性并解析 payload；实例只保存运行态缓冲指针。

## 15. 实验建议
- 比较复制版 vs 享元表 RAM/Flash 使用。
- 查找策略（线性 vs 二分 vs 哈希）性能测试。

## 16. MISRA / AUTOSAR 注意
- 常量数据 constexpr + const 限制写。
- 索引使用需边界检查。

## 17. 面试 / Review 问题
- Flyweight 与 Prototype 的差异？
- 如何识别内在 vs 外在状态？
- 查找性能如何优化？

## 18. 练习
基础：将重复命令元数据改成共享表。
提高：实现二分查找与线性查找对比。
思考：设计共享滤波系数表 + 各实例 state 分离。

## 19. 快速回顾
- 共享不可变数据减少内存
- 区分内在/外在状态关键
- 与 Prototype/对象池组合常见
