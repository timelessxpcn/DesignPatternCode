# 外观模式 (Facade Pattern)

## 1. 意图
为复杂子系统提供统一的简化接口，屏蔽内部模块交互细节，降低调用复杂度和耦合。

## 2. 问题背景 / 动机
系统启动需初始化：时钟、GPIO、传感器、通信、存储、校准数据加载。初版在 `main()` 中手工调用大量函数，顺序与依赖易错。外观模式将流程聚合到 `SystemFacade::init()` 等统一入口；上层调用简化、测试可分离模拟子系统失败情况。

## 3. 适用场景
- 板级初始化 (BSP)
- 功耗模式切换（挂起/恢复子系统）
- 复杂通信栈启动（队列、缓冲、协议层）
- 系统诊断汇总

## 4. 结构概述
Facade 拥有各子系统（组合/引用），对外暴露少量高层方法。内部可调用子系统提供的细粒度 API。与 Adapter 区别：Facade 不改变接口，只是“打包简化”。

## 5. 基础实现（初始化外观）
```cpp
class Clock { public: bool init(); };
class Sensors { public: bool init(); };
class Comm    { public: bool init(); };

class SystemFacade {
public:
    bool initAll(){
        if(!clock_.init()) return false;
        if(!sensors_.init()) return false;
        if(!comm_.init()) return false;
        return true;
    }
    void enterLowPower(){
        // 统一调用子系统 lowPower()
    }
private:
    Clock clock_;
    Sensors sensors_;
    Comm comm_;
};
```

## 6. 嵌入式适配要点
- 顺序依赖明确 (clock -> sensor -> comm)。
- 错误传播：返回状态码 / 位图。
- 低功耗：切换时序集中管理。
- Facade 自身不应持有巨大缓冲（转交给子系统）。

## 7. 进阶实现
### 7.1 可配置 Facade（策略/指针注入）
注入不同实现（Mock / Real）。
### 7.2 分阶段初始化
`initPhase1()`（时钟/内存）→ `initPhase2()`（外设）→ `initPhase3()`（通信）。
### 7.3 条件编译组件
使用宏或配置结构启用某些子系统（减尺寸）。

## 8. 资源与实时性评估
- 调用封装，额外开销极小（函数包装）。
- 集中化可能增加栈深（注意内联/分阶段）。

## 9. 替代比较
- 直接调用子系统：简单但散乱。
- 管理器单例：Facade 可不必限制为单例（但可结合）。
- Builder：着重构造复杂对象；Facade 着重统一接口。

## 10. 可测试性与可维护性
- 可模拟某子系统失败路径。
- 易于注入 Mock 子系统（接口化）。
- 变更子系统内部不会影响上层调用点。

## 11. 适用性检查清单
Use：
- 上层频繁需要一串固定调用序列
- 子系统依赖关系复杂
Avoid：
- 子系统极简/调用少
- 仅为隐藏 2-3 个函数而增加层

## 12. 常见误用 & 修正
误用：Facade 内部写大量逻辑变成“上帝对象”。  
修正：保持薄层，业务逻辑仍在子系统。

误用：Facade 直接泄漏内部指针给外部修改破坏封装。  
修正：暴露只读或受限接口。

## 13. 与其它模式组合
- 单例：系统外观单例
- 抽象工厂：Facade 中使用工厂创建子系统
- 代理：Facade 内部访问远程/延迟子系统

## 14. 案例
`SystemFacade::initAll()` 聚合：Clock, Storage(mount), Sensors(calibration), Comm(open), Logger(start)；失败时记录错误码映射。

## 15. 实验建议
- 比较 main() 中散乱调用 vs Facade 封装代码行差异
- 故障注入：模拟 sensor init 失败

## 16. MISRA / AUTOSAR 注意
- 错误码统一枚举
- 避免隐藏全局状态修改

## 17. 面试 / Review 问题
- Facade 与 Adapter 区别？
- 如何避免 Facade 膨胀？
- 出错回滚策略设计？

## 18. 练习
基础：添加 storage 子系统并整合。
提高：实现分阶段 init + 错误回滚。
思考：如何在低功耗唤醒时最小化重新初始化时间？

## 19. 快速回顾
- 简化复杂子系统入口
- 关注依赖顺序与错误传播
- 保持薄层，避免“上帝对象”
```

````markdown name=patterns/chain_of_responsibility.md
# 责任链模式 (Chain of Responsibility)

## 1. 意图
使多个处理者有机会处理请求，将处理逻辑串联成链，按顺序传递直到某一处理者处理或链结束。

## 2. 问题背景 / 动机
嵌入式报文/事件处理管线：校验 → 过滤 → 解码 → 分发，多层 if 嵌套臃肿；希望可动态启用/禁用某过滤器，并在其中一个阶段决定“取消后续处理”。

## 3. 适用场景
- 通信帧处理：CRC 校验、地址过滤、解密、解析
- 输入事件过滤（去抖、阈值、映射）
- 日志过滤链（级别 → 采样 → 输出）
- 命令权限校验 → 参数规范化 → 执行

## 4. 结构概述
Handler 接口 + 指向下一个 Handler。调用 `handle(req)` 若处理不了则传递。嵌入式可使用：
- 数组 + 返回值控制继续
- 函数指针表 + 统一签名

## 5. 基础实现（函数指针数组）
```cpp
struct Packet { const uint8_t* data; size_t len; bool drop=false; };

using HandlerFn = void(*)(Packet&);

void crcCheck(Packet& p){ /* set drop if fail */ }
void filterAddr(Packet& p){ /* ... */ }
void decode(Packet& p){ if(!p.drop){ /* parse */ } }

HandlerFn chain[] = { crcCheck, filterAddr, decode };

void process(Packet& p){
    for(auto fn: chain){
        fn(p);
        if(p.drop) break;
    }
}
```

## 6. 嵌入式适配要点
- 通过布尔/状态码终止链。
- 可使用位图启用/禁用处理器（无需修改数组）。
- 性能关键路径：尽量内联函数或减少分支。
- 避免动态添加/删除（使用静态固定表 + 激活标志）。

## 7. 进阶实现
### 7.1 优先级排序
启动时对处理器数组按优先级排序一次。
### 7.2 早停计数
限制最大处理深度防止逻辑错误导致死循环（若链结构动态）。
### 7.3 模板流水线
模板参数包展开内联处理（编译期固定链）。

## 8. 资源与实时性评估
- 复杂度：O(n)；n 为处理器数
- 早停减少平均耗时
- 表驱动方式闪存较小；模板内联可能增大代码尺寸

## 9. 替代比较
- 装饰器：总是继续（不强调终止）
- 策略：从一组选择一个，不是串行链
- 观察者：广播所有，不可中断

## 10. 可测试性与可维护性
- 单测：构造包通过不同阶段断言 drop 状态
- 测试链顺序改变影响（验证排序函数）
- 测试启用/禁用配置加载

## 11. 适用性检查清单
Use：
- 多步处理允许提前终止
- 处理器顺序关键
Avoid：
- 只有 2-3 步且不会终止（直接函数串调用）
- 必须全部执行（装饰器更合适）

## 12. 常见误用 & 修正
误用：处理器修改共享状态副作用不可控。  
修正：限定输入输出结构或只读区域。

误用：链中处理器阻塞/长耗时。  
修正：拆分异步或前后分层。

## 13. 与其它模式组合
- 工厂：按配置构建链
- 对象池：处理节点临时对象复用
- 命令：链末尾转换为命令入队

## 14. 案例
串口帧处理：校验失败 -> drop；通过后地址过滤；通过后解析协议字段。

## 15. 实验建议
- 测量平均处理时间（有/无提前终止）
- 处理器数量对性能曲线

## 16. MISRA / AUTOSAR 注意
- 函数指针必须有效
- 避免未初始化状态使用

## 17. 面试 / Review 问题
- 与装饰器差异？
- 如何动态启用/禁用处理器？
- 提前终止逻辑失效如何检测？

## 18. 练习
基础：添加加密解密处理器（若失败 drop）。
提高：实现启用位图控制链执行。
思考：如何记录链上哪一步丢弃了包以便统计？

## 19. 快速回顾
- 串行处理可早停
- 函数指针表轻量高效
- 注意链深和阻塞阶段
