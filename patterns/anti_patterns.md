# 常见反模式与误用 (Anti-Patterns in Embedded Design Patterns)

> 目标：帮助识别“什么时候不该用模式”与“模式误用成本”，避免过度设计。

## A. 单例泛滥 (Singleton Everywhere)
症状：
- 到处 `Something::instance()`，隐藏依赖
- 单测难以隔离
风险：
- 初始化顺序问题
- 难以并行测试或多实例模拟
修正：
- 依赖注入（构造参数/接口）
- 减少全局状态；必要时提供可替换接口指针

## B. 上帝对象 (God Object)
症状：
- Facade / Manager 持有几乎所有子系统指针 + 业务逻辑
风险：修改回归范围大，职责不清
修正：拆分明确子模块；Facade 仅协调流程

## C. 过度抽象 (Over-Engineering)
症状：
- 少量功能引入多层虚接口/抽象工厂
风险：代码尺寸增、学习曲线高
修正：
- 开始用简单结构（函数/结构体）→ 需求扩展再抽象
- 评估“扩展概率”

## D. 继承滥用 (Inheritance Abuse)
症状：
- 为了复用实现使用深层继承
风险：二义性、虚调用开销、隐藏耦合
修正：
- 优先组合 (has-a) 与 CRTP / 模板策略
- 限制继承层数（<=2）

## E. 模板膨胀 (Template Bloat)
症状：
- 每种策略/状态组合实例化新模板
风险：Flash 增长、编译时间长
修正：
- 对高频路径保留模板；可变少量使用虚调用/函数指针
- 链接时分析重复实例，适度合并

## F. 动态分配无节制
症状：
- 中断/实时路径 new/delete
风险：碎片化、不可预测延迟
修正：
- 对象池 / 静态缓冲
- 启动阶段集中分配

## G. 误用装饰器（微层碎片化）
症状：
- 每层仅 1-2 行逻辑，构成长链
风险：调用开销累积、难调试
修正：
- 合并小层
- 使用函数数组或单函数聚合

## H. 滥用访问者
症状：
- 节点类型频繁变化仍坚持访问者
风险：修改成本高、样板泛滥
修正：
- 使用 variant + visit
- 或 switch 简化

## I. 命令模式过度细粒度
症状：
- 大量 trivial 命令（例如“加 1”）
风险：队列压力、调度开销高
修正：
- 批处理命令
- 合并参数 / 累积后执行

## J. 责任链无监控
症状：
- 链太长、不可见早停点
风险：性能不可预测
修正：
- 链执行统计 + 日志
- 限制最长深度

## K. 单线程伪并发
症状：
- 通过事件/命令/观察者层层转发，逻辑不透明
风险：排查困难
修正：
- 文档化数据流
- 减少重复中间层

## L. 宏魔法 (Macro Abuse)
症状：
- 用宏生成模式样板
风险：调试难、类型不安全
修正：
- 使用模板/constexpr/内联函数

## M. 内联过度 (Over-Inlining with Templates)
症状：
- 追求零开销内联所有层
风险：Flash 爆炸、I-cache miss
修正：
- 保持“热点”内联，冷路径使用多态/函数调用

## N. 全局事件风暴
症状：
- 大量观察者通知高频事件
风险：CPU 消耗、不可预测延迟
修正：
- 降采样 / 合并事件
- 背压与节流

## O. 多模式叠加无必要
症状：
- 同一职责上使用策略+装饰+代理+责任链
风险：调试困难
修正：
- 明确主要意图 → 只保留真正增值的层

## 自检清单（新增模式前回答）
1. 问题能否用简单函数 + 结构解决？
2. 是否有真实扩展需求或概率 > X%？
3. 性能/内存成本可接受？
4. 测试是否更容易？
5. 是否引入了隐藏耦合？

## 度量建议
- 模式引入前后：代码行/复杂度/Flash/峰值 RAM
- 模式使用频率 vs 缺陷数量
- 构建时间变化

## 练习
1. 给一个过度设计实例，列出可裁剪层。
2. 分析一个全局单例日志导致测试困难的场景，重构方案。
3. 对一条责任链添加性能监控（统计平均处理时间）。

## 快速回顾
- 模式是手段非目标
- 嵌入式侧重“确定性 + 资源”权衡
- 反模式识别与量化指标结合持续审查
